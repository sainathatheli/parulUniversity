What is a Database?

A Data Base is an Organized Collection of Data which can be easily
accessed, managed and updated.
In today’s World, Data plays a vital role in every business. In our day to day life, we see or
interact with many applications and Software’s, every application that we see or work with will
have two parts:

1. GUI (Graphical User Interface / Front end)
2. Database

To keep it simple GUI is the part where user interacts with (like Facebook applications – look
and feel) and the Data that we see in the application (like Facebook profile, messages, images
and videos) are pulled from Database.


End User who interacts with the application may not know how the data is being fetched and
where so much of information is stored. Internally all the dynamic content that we see in the
application is fetched from Database.

Database and all its components should be designed and configured at the time of application
development. Once the application is developed we will not be able to make changes to the
database structure as every change will hugely affect the business application GUI code.
It is very important to make sure that data is securely maintained and accurately stored. 

So to maintain security and accuracy in database a set of rules / software system is defined and that
we call it as DBMS (Data Base Management System – which performs all the operations on the
database)

What is DBMS?

DBMS (Database Management System) is a software tool that is used to store and manage data
in the Database.

A database management system contains a set of programs that control the creation,
maintenance, and use of a database. Like:

Adding new data to the table.
Modifying existing data.
Deleting unwanted data.

DBMS allows different user application programs to concurrently access the same database.
Before Database and DBMS were introduced, traditional approach was to store data in flat files
(physical files in system) but there were some disadvantages with it.

What is RDBMS?
A relational database management system (RDBMS) is a Database Management System
(DBMS) that is based on the relational model introduced by E. F. Codd and most popular 
databases currently in use are based on the relational database model. To put in different 
words RDBMS is built on top of in which data is stored in tables and the relationships among 
the data are maintained. The data stored in a table is organized into rows and columns. Each 
row in a table represents an individual record and each column represents a field. A record is 
an individual entry in the database.

Difference between DBMS and RDBMS
----------------------------------
For example, consider the database which stores employee information. 
In DBMS, all details like empno, ename, job, salary, deptno, dname, location, street, city, state, phone will 
be stored in a single table. 

But in RDBMS, the data model will be designed in such a way that 
like the empno, ename, job, salary and deptno will be stored in emp table and deptno, dname, location will be stored in dept table and location, street, city, state, phone will be stored under locations table. 

Any information to be obtained is done by properly relating the ‘emp’, ‘dept’ 
and ‘locations’ tables.




SQL:
====
SQL stands for Structured Query Language. 

It is used for storing and managing data in relational database management system (RDMS).

It is a standard language for Relational Database System. It enables a user to create, 
read, update and delete relational databases and tables.

All the RDBMS like MySQL, Informix, Oracle, MS Access and SQL Server use SQL as their
standard database language.
SQL allows users to query the database in a number of ways, using English-like statements.

Rules:
SQL follows the following rules:

Structure query language is not case sensitive. 
Generally, keywords of SQL are written in uppercase.
Statements of SQL are dependent on text lines. 
We can use a single SQL statement on one or multiple text line.
Using the SQL statements, you can perform most of the actions in a database.

  sql stands for structure query language designed for
accessing and managing the data in the RDBMS

Sql act as interface between user and database.

why sql ?
=========

Sql can retrieve records from the database.

sql can insert record into the database

sql can update record in to a database

sql can provides privileges to pprocedures,functions,
views, sequences----database objects


Sql is divided into five categories:
====================================

DDl --DATA  DEFINITION LANGUAGE     
-------------------------------
CMDS:CREATE,ALTER,TRUNCATE,DROP,RENAME

which deals with database schemas and descriptions, of how the data should reside in the database.
                            
DML -- DATA MANIPULATION LANGUAGE
-----------------------------------

CMDS:INSERT,UPDATE,DELETE

which deals with data manipulation and includes most common SQL statements such 
INSERT, UPDATE, DELETE, etc., and it is used to store, modify, retrieve, delete and update data in a database.

DCL -- DATA CONTROL LANGUAGE
-----------------------------
GRANT,REVOKE

TCL -- TRANSACTION CONTROL LANGUAGE
-------------------------------------
COMMIT,ROLLBACK,SAVEPOINT

DRL -- DATA RETRIVEAL LANGUAGE
------------------------------
SELECT

 Oracle Datatypes:
 =================

 Number[(p,s)]:-  this data is used to store numeric data
                   maxisize we can store up to 38 digits
                
                 p--precision
                 s--scale
  ex:
  ====

  empno number
 
  empno number(5)

  sal  number(10,3); -- 10 is precision and 3 is scale.
 

  Example:
  =======
   The precision is the number of digits in a number. It ranges from 1 to 38.
   The scale is the number of digits to the right of the decimal point in a number. 
    It ranges from -84 to 127.
   
   For example, the number 1234.56 has a precision of 6 and a scale of 2.
   So to store this number, you need NUMBER(6,2).




  char[(size)] :-  this is used to store fixed characters
                  maximum size is 2000 bytes.

  nchar[(size)] :-  this data type is used to store  
                 national characters ,maxmimum size is 2000 bytes.

  varchar(size) :- this data type is used to string type of data.
                  maximum size is 2000 bytes.

  varchar2(size) :-- this datda type is used to store string type of data
                    maximum size is 4000 bytes.

 Difference varchar(size) and varchar2(size):
 ============================================

 ex:
  ===

 ename varchar(10);                 ename varchar2(10);
 suppose a user
 enter smith			     suppose user
 interanlly                             enter  smith
         
                                     internally the sql egine 
 it will allocate                     will allocate the 
 memory based on                      memory based on user 
                                     enter value.
 variable datatype size
                                       ------
----------			       smith
smithnnnnn


remaining character will
be fillup with nullvalues
at right side
 

size if fixed                         size is variable value length




Date:--  
========
        this datatype is used to store valid date
          by default the oracle use the date format
          DD-MON-YYYY.
          Date range :- from 1 jan 4712 BC to 31 dec 9999 A.D

 TImestamp:
 ===========
 thid datatype is used to store valid date(year,date,month) and time
 (HH:MM:SS:MS)


 AnsI(american national standards institution)
 ===========================================
  Int
 Float
 Decimal
 varchar
....etc


 LOB (large binary objects)dataypes:
 ====================================

  Bfile :- it will stores the locations of file.
 
 BLOB --to store unstructured data -- maximum size is 4gb.

 ClOB -- to store character of binary single character or
         multiple characters of data ---maximum size is 4gb.















 ROWID:
 ======
 Every record in database contains physical address or rowid

1001 smith 3000
1001 smith 3000
1003 raju   4000
1005 rakesh 5000
1001 smith  3000

 XML:
 ====
 to store xml data --semi structure data --Introduced in oracle11g 

Eg:
===
 <empi>
 <empno>1001</empno>
 <ename>smith</empno>
 <sal>3000</3000>
  </empid>







 Note:
 =====
 insert the values for varchar,varchar2,date  datatypes
 in single code('');


 DDL:
 =====

 DDL stands for Data definition language.

 DDL is used to define the definitions or schema or structure and
 modify the definitions or schema or structure in the database.

 DDl commands are auto commit commands.

 DDL commands are
 -----------------
 create,alter,rename,truncate,drop


create:
=======

create command is used to define the database objects.

database objects are table,view,sequenc,procedure...etc


To create a table syntax:
========================

syntax:
=======


create table <tablename>(
               columnam1 datetype(size) [constraints],
               columname2 datatype(size)[constraints],

                 ---------
                ----------------------
		columnamen datatype(size)[constraints]
             );


tablename conventions:
======================

tablename should be 30 character
tablename should contain numbers and underscore
tablename cannot start with number.
tablename is not case sensitive.
tablename cannot contain space.

ex1
===
create table emp11 it contains the columns

columns          datatype       length
empno             number          5
ename		varchar2           10
sal              number           10,2


solu:
=====
create table emp11(empno number(5), ename varchar2(10),sal number(10,2));
								
or

mysql
------
create table emp11(empno int(5),ename varchar(10),sal decimal(10,2));
sol:
====

create table  emp11(
                     empno  number(5),
                     ename  varchar2(10),
                     sal    number(10,2),
                    hiredate  date);




Ex2:
----
create table  named as    product_11
fields or columns --     pid,pname,price


insert five records


sol:
====
create table product_11(pid number(5),pname varchar2(10),price number(5,2)):

Ex:3
=====
create table named as course

fields or columnname   dataype   size
cid                   number      4
cname                 varchar2   20
joindate              date
course_end_date         date

  
to list all the table from a user:
===================================

cmd:  select * from tab;


to clear screen:
=================
cmd: cl scr


to show the current user:
==========================
cmd: show user;


to describe the table structure:
================================

syntax:
========

desc[ribe] tablename;



Insert some records into emp11 table:
=====================================


syntax:
=========

insert into tablename values(column-value,----columnn-values);

sol:
====

insert into emp11 values(1001,'smith',20000);

insert into emp11 values(1002,'martin',30000);

insert into emp11 values(1003,'chaitnaya',20000);

insert into emp11 values(1004,'raju',10000);

insert into emp11 values(1005,'harsha',40000);




commit; --to store the records permanently in table. 


to list all the records from the table:
=======================================

syntax:
-======

select * from tablename;

ex:
===

select * from emp11;


copy a table with schema with out data from existing table
==========================================================

syntax:
========

create table tablename as select * or[specific columns]
                               from tablename where anyfalse condition;


ex2:
====

create a table emp_11(empno,ename,sal) from emp11 table without data.

solu:
======


create table emp_11 as select empno,ename,sal from emp11 where 1=2;


copy a table with schema with data from existing table
==========================================================

syntax:
=======

create table tablename as select * or[specific columns]
                                       from tablename;


ex:
===

create a table emp_with_date (empno,ename,sal) from
existing table emp11 with data.


sol:
====

create table emp_with_data as select empno,ename from emp11;


to clear the screen:
====================

oracle -- cl scr
mysql -- clear or  ctrl+L
IBMDB2 !cls


Alter:
=======

alter command is used to modify the definition(structure) of a table.


1)to add a new column to an existing table:
============================================

syntax:
=======

alter table tablename add columname datatype ;

or

alter table tablename add (column datatype,columname datatype);

note:
=====

all columns added to table at last.


2)modify the column datatype size or change column datatype
============================================================

note:
=====

to decrease the size of a column first we need to make
column as empty.

to change the column datatype then first we need to
make the column as empty.


syntax:
========

alter table tablename  modify  columnname datatype(size)

 or

alter table tablename modify  (columnname datatype(size),columname datatype(size));


3) to drop a column from the table:
====================================

syntax:
=======

alter table tablename drop column  columname;


4) to rename  a column:
========================

syntax:
=========

alter table tablename rename column  colunname to newcolumname;




5)to add a constraint for column:
==================================

syntax
------
alter table tablename add constraint constraintname;


6) to drop a constraint for a column:
======================================

syntax:
========

alter table  tablename drop constraint  constraintname;


example:
=========
Already we have emp11 table:


alter operations on emp11:
==========================

a) add column mobileno 

sol:
=====
alter table emp11 add mobileno number(10);


b) add columns address,job
============================
sol:
---------

alter table emp11 add (address varchar2(20),job varchar2(20));


c)current size of ename is 10 then
  increase the size of ename column to 20;

sol:
=====

alter table emp11 modify ename varchar2(20);


d) alter the datatype of mobileNo from number to varchar

sol:
----
alter table emp11 modify mobileno varchar2(10);

mysql
-----
alter table emp11 modify mobileno varchar(10);

Ex:
---
increase the size of ename column 10 to 20 

--
alter table emp11 modify ename varchar(20);


d)drop a column  address;

sol:
====

alter table emp11 drop column address;


e)rename a column job  to designation
==========================================

sol:
----
alter table emp11 rename column  job to designation;


7) adding  constraint at alter level:
--------------------------------------
add primary key for existing table emp11 for empno.

sol:
----
alter table emp11 add primary key(empno);



RENAME(for table name):
==================
Rename is  used to rename the table.

syntax:
=======
oracle:
-------
rename oldtablename to  newtablename;

mysql:
------
rename table oldtablename to  newtablename;

ex:
===
write a query to rename a product_11 to product_22 ?

Ex:
---
Mysql:
------
rename table product_11 to product_22;


truncate:
=========

this command is used to delete all the records or data
from the table but not schema. we cannot rollback(truncate is
auto commit cmd).

syntax:
=========

truncate table tablename;

ex:
===

write a query to trunate a table emp11 ?

sol:
===

truncate table emp11;


Drop :
======

this command is used to drop  the database objects. 
it will drop data from the table as well as schema.

database objects:- table,view,sequence,procedure..etc


to drop a table:
=================

syntax:
-------

drop table tablename;

or

to drop a table which contains constraint:
==========================================
syntax:
=======
drop table tablename cascade constraints;


DML
====
DML stands Data Manipulation language.

Dml commands are not auto commit commands,
we need to explicitly commit the DML statements.

DMl commands are:
==================
insert,update,delete


insert:
======
insert command is used to add record into a table.

syntax:
=======
insert into tablename values(column value1,col-value2...,colvalue-N);

EX:
---
create table emp11(empno int(5),ename varchar(10),sal decimal(10,2));

insert into emp11 values(1001,'smith',20000);

insert into emp11 values(1002,'martin',30000);

insert into emp11 values(1003,'chaitnaya',20000);

insert into emp11 values(1004,'raju',10000);

insert into emp11 values(1005,'harsha',40000);


insert  with specific columns:
================================

it is used to insert the data for specific columns

syntax:
=======


insert into tablename (columnname1,coluname2,---columname3)
             values(columnvalue1,columnvalue2,---columnname3);

ex:
====

write a query to insert record for specific columns(empno,ename) into 
table emp11;

sol:
====

insert into emp11 (empno,ename) values(1005,'dsds');

or
insert into emp11 (empno,ename) values(&empno,'&ename');



insert into select
=================

syntax:
========

insert into trg_tablename select columnslist from src_tablename;

note:
=====
the trg_tablename columnames and src_tablename columns
should have the same schema(column data type).

Ex:
---
create table emp_dup(empno int(5),ename varchar(10));

insert into emp_dup select empno,ename from emp11;




update:
=======
update is used to modify the column values.

syntax:
=========
update tablename set columname=value,columnname=value where condition

note:
=====
if where condition is not specified total records will be
updated in the table.

ex:
===

write a query to update a column ename raju to another name
where empno 1004?

solu:
=====

update emp11 set ename='rajuhadoop' where empno=1004;

ex:
---
update the sal column of empno =1006.

sol:
----
update emp11 set sal=4000 where empno=1006











write a query to update a column ename and sal where
empno 1005?

sol:
=====

update emp_11 set ename='sdsd',sal=4000 where empno=1005;


Assignment:
===============
update as select;
Difference between truncate and delete?



delete:
========

this command is used to delete a specific record
or all the records.


syntax:
=======

delete from tablename where condition; --specific record

or

delete from tablename -----all record will be deleted.

or

delete tablename where condition.


ex:
---
delete the record of empno 1006

sol: delete from emp11 where empno=1006;


Exercise
-------------------------------
1. Create table emp12 from table emp ?(Hint : use emp table)-->copy a table
    Ans: create table emp12 as select * from emp;

2. create table emp13 from emp and into the new table copy only the structure but do not copy data ?
   Ans: create table emp13 as select * from emp where 5=10


3. Increase size of ENAME field to 20 use emp13 table?
   Ans: alter table emp13 modify ename varchar(20);


ALias names:
=============

alias name is temporary name for column or table.

syntax:
=======

coluname  as aliasname

or

columname aliasname

columnae "Hire_date"


ex:
====

select empno,ename,sal as salary from emp_11;


select e.empno,e.ename,e.sal from emp e;


 CONSTRAINTS:
 ============
 CONSTRAINT IS A RULE OR RESTRICTION WHICH IMPOSED ON COLUMNS
 OF THE TABLE.
 
 CONSTRAINTS CAN BE APPLIED AT THE TIME OF COLUMN DEFINITION.

 CONSTRAINTS CAN BE APPLIED AFTER THE TABLE DEFINITION

 CONSTRAINSTS CAN BE APPLIED AT THE ALTER .


 CONSTRAINTS ARE DIVIDED INTO THREE

 1)DOMAIN INTEGRITY CONSTRAINTS
 -------------------------------
 NOT NULL
 CHECK

 2)ENTITY INTEGRITY CONSTRAINTS
 --------------------------------

 UNIQUE
 PRIMARY KEY

 3)REFERENTIAL INTEGRITY CONSTRAINTS
 ------------------------------------

 FOREIGN KEY


  1)DOMAIN INTEGRITY CONSTRAINTS:
  ================================

   NOT NULL :
    ==========

   NOT NULL CONSTRAINT ARE USED TO AVOID NULL VALUES FOR THE
   SPECIFIED COLUMNS.

   WE CAN APPLY THESE CONSTRAINT AT COLUMN-LEVEL

  EX:
  ===

  CREATE A TABLE WITH NOT NULL CONSTRAINT WITH OUT NAME FOR EMPNO COLUMN.

  SOL:
  ====

  CREATE TABLE EMP_1(EMPNO int NOT NULL,
                          ENAME VARCHar(10),SAL 
                          decimal(10,2));
 
 insert into emp_1 values(null,'smith',4000); //in valid
   Error : empno cannot be null


 insert into emp_1 values(101,'martin',null);//valid
 insert into emp_1 values(102,null,4000);  //valid



check constraint:
------------------
Based on condition to restrict columns.

syntax:
------
check (condition)

Ex:
----
create a table named as emp_2 which contain fours (empno,ename,sal,gender)
using check constraint  restrict the user to choose either (M or F)

sol:
----
create table emp_2 (empno int not null,ename varchar(10),sal decimal(10,2),
                       gender char(1) check (gender='M' or gender='F'));


insert into emp_2 values(1001,'smith',4000,'c');   //invalid
ERROR 3819 (HY000): Check constraint 'emp_2_chk_1' is violated.

insert into emp_2 values(1001,'smith',4000,'M'); //valid



unique:
-------
Unique constraint restrict the enduser not to enter null values and duplicates.

syntax:
-------
unique(columname)

ex:
----
create a table product(pid,pname,price)
apply the constraints unique constraint to pid
                       for pname,price not null


sol:
-----
create table product(pid int(5) unique,
                       pname varchar(10) not null,
                        price float not null);


insert into product values(1,'mouse',400);//valid
insert into product values(null,'pendrive',800);//valid
insert into product values(1,'ram',4000);//invalid
 errorcode : duplicate entry


primary key:
-------------
it a combination of NOT NUll + Unique

A table contain have one primary key.

syntax:-
--------
alter level:
------------

alter table tablename add primary key(columname);


column level:
-------------
syntax: create table(colunname1 datatype primary key,
                      columname2 datatype,
                      columname3 datatype);

ex:
---
create table item(itemid ,itemname,qunatity).
Here add the primpary at column level for itemid)

sol:
----

create table item(itemid int(4) primary key,
                    itemName varchar(10),
                    quantity int(4));


insert into item(null,'fastfood',4);//  error  itemid cannot be null
insert into item(1,'juices',5);//valid
insert into item(1,'fruits',5); //duplicate entry found



table-level:
=-------------
create table item2(itemid int(4),
                    itemName varchar(10),
                    quantity int(4),
                    primary key(itemid));  //table-level




insert into item2(null,'fastfood',4);//  error  itemid cannot be null
insert into item2(1,'juices',5);//valid
insert into item2(1,'fruits',5); //duplicate entry found


foreign key:
-------------
To make parent and child relation ship between the tables.

Will use keyword : REFERENCES

To make relation the tables should contain common column.


Ex2:
----
Address Table(aid -pk,state,pin) --Parent
Employee Table(eid -pk,ename,sal,aid ) --Child

Create a relation with Address and employee table using foreign key at table level.

Table level syntax:
------------------
foreign key(childtable column name) references parenttable(primary key column name)

Ex:
---
create table address(aid int(4) primary key,state varchar(10),pin int(6));


create table employee(eid int(4) primary key, ename varchar(10),sal decimal(10,2),
                          aid int(4),
                          foreign key(aid) references address(aid));


First insert the data in address:
---------------------------------

insert into address(1,'Mumbai',500043);
insert into address(2, 'hyd',500053);


Employee:
---------
insert into employee(1001,'smith',4000,2);
insert into employee(1002,'martin',5000,1);


insert into employee(1003,'Allen',4000,3);//foreign key constraint failed

delete from address where aid=1; //Cannot delete or update a parent row: a foreign key constraint fails


Restrictions on foreign key:
---------------------------
On delete cascade:- to delete a record from parent table along with depends records will deleted.

synatx:
===========
foreign key(childtable column name) references parenttable(primary key column name) on delete cascade;

Ex:
---
create table address_1(aid int(4) primary key,state varchar(10),pin int(6));


create table employee_1(eid int(4) primary key, ename varchar(10),sal decimal(10,2),
                          aid int(4),
                          foreign key(aid) references address(aid) on delete cascade);

First insert the data in address:
---------------------------------

insert into address_1(1,'Mumbai',500043);
insert into address(2, 'hyd',500053);

Employee:
---------
insert into employee_1(1001,'smith',4000,2);
insert into employee_1(1002,'martin',5000,1);

insert into employee(1003,'Allen',4000,3);//foreign key constraint failed
delete from address where aid=1; // it will delete parent and child records.


to list all the constraints on a table:
---------------------------------------
show create table tablename;

ex:
---
show create table employee;


from above the command get the name of the constraint, and drop the constraint using alter
ex:
---
alter table employee drop foreign key employee_ibfk_1;


to drop a primary key:
------------------------
alter table customer drop primary key;


 RELATIONAL OPERATORS:
 =====================
  > -- GREATER THAN
  <  --- LESS THAN
  <= ---LESS THAN OR EQUAL TO
  >= --- GREATER THAN OR EQUAL TO
  == --- EQUAL TO
  !=  <>  -- NOT EQUAL TO

  BETWEEN -- RETURNS THE VALUE ,THE VALUE SPECIFIED IN THE RANGE.
            (INCLUSIVE)

  IN --- RETURNS THE VALUE ,THE VALUE AVAILABLE IN THE
                          GIVEN LIST OF VALUES.

 EXAMPLES:
 =========

  1)WRITE  A QUERY TO DISPLAY THE RECORDS WHERE SAL LESS THAN 2000
  FROM EMP TABLE

 SOL:
 ====

  SELECT * FORM EMP WHERE SAL<2000;

  O/P:- 8 RECORDS.


 2)WRITE A QUERY TO DISPLAY RECORD WITH SPECIFIED RANGE
  SAL 2000 AND 3000;

 SOL:
 ====

 SELECT * FROM EMP WHERE SAL>=2000 AND SAL<=3000; 

 OR

 SELECT * FROM EMP WHERE SAL BETWEEN 2000 AND 3000; 

 OLP:-5 RECORDS


 3)WRITE A QUERY TO DISPLAY THE RECORDS BASED ON IN WHERE
 SAL 1000,2000,3000 ON EMP TABLE.

 SOL:
 ====

 SELECT * FROM EMP WHERE SAL=1000 OR SAL= 2000 OR SAL=3000;
 OR
 SELECT * FROM EMP WHERE SAL IN(1000,2000,3000);


 ORDER BY CLAUSE:
 ================
 THIS CLAUSE IS USED TO SORT THE OUTPUT STATEMENT BASED ON SELECT
 QUERY.

 BY DEFAULT IT SORT ASCENDING OR ASC

 DESCENDING  
 -----------
DESC

 SYNTAX:
 ========
 SELECT * FROM TABLENAME [WHERE][group by] [having by] [ORDER BY COLUMNANME...]

 EX:
 ===
  WRITE A QUERY TO DISPLAY THE RECORD FROMM EMP BASED ON
  SAL COLUMN IN ASCENDING.

  SOL:
  =====
  SELECT * FROM EMP ORDER BY SAL ;

  OR

  SELECT * FROM EMP ORDER BY SAL DESC; --DESCENDING ORDER



  GROUPED FUNCTIONS OR AGGREGATE FUNCTION OR SINGLE ROW FUNCTIONS:
  =================================================================

  SUM 
  AVG
  MIN
  MAX
  COUNT
 
  DISTINCT -- TO REMOVE DUPLICATE VALUES


  EX:
  ===

  1)WRITE A QUERY TO COUNT NO OF RECORDS IN EMP TABLE.

  SOL:
 
  ====

   SELECT COUNT(*) FROM EMP;

  2)WRITE A QUERY TO FIND MAX SAL FROM EMP.
 
  SOL:
  ====

  SELECT MAX(SAL) FROM EMP;


 3) WRITE A QUERY TO FIND SECOND MAX SAL.
   WE CAN WRITE THIS QUERY USING DENSE RANK OR SUBQUERY.


 4) WRITE A  QUERY TO PEFROM SUM OF SAL  OF ALL EMPLOYESS  IN EMP TABLE.
 
SOL:
====
SELECT SUM(SAL) FROM EMP;

O/P: 30325

 5)select Distinct(sal) from emp;


 GROUP BY CLAUSE:
 ================
 THIS CLAUSE IS USED TO GROUP OF RELATED INFORMATION.


 SYNTAX:
 =======

  SELECT * FROM TABLNAME [WHERE][GROUP BY COLUMNNAME][ORDER BY COLUMNS];

 EX
 ===
 WRITE A QUERY TO PERFORM SUM OF SALARIES BASED ON EACH
 DEPARTMENT NO FROM EMP TABLE.

 SOL:
 ====
 SELECT DEPTNO,SUM(SAL) FROM EMP GROUP BY DEPTNO;


 2) WRITE A QUERY TO PERFROM SUM OF SALARIES BASED ON EACH
  DEPARMTENT NO AND COUNT NO EMPLOYESS IN EACH DEPT FROM EMP.

SOL:
====
SELECT DEPTNO,COUNT(*),SUM(SAL) FROM EMP GROUP BY DEPTNO;


  3)WRITE A QUERY TO PEFROM SUM OF SALARIES BASED ON
   EACH DEPTNO AND EACH JOB .

  SOL:
  ====

  SELECT DEPTNO,JOB,SUM(SAL),count(*) FROM EMP GROUP BY DEPTNO,JOB;


 3)Having clause:
  ================
 to filter the grouped the data then we need to go for having clause;
  
  syntax:
  -------
   select * from tablename [where][group by][having][order by]

   Ex;
   ===
   Write a query to sum(sal) of each dept greater 8750?

   sol:

   select Dept,sum(sal) from emp group by deptno having sum(sal)>8750  order by deptno

  or

 select deptno,sum(sal) as sumsal from emp group by deptno having sumsal>8750 order by deptno desc
   
   LIKE OPERATOR:
 ==============

  IT WILL RETRUN THE VALUE BASED ON SEARCH OF PATTERN

  THERE ARE TWO PATTERNS

  %   ->PERCENATAGE-- REPRESENT ONE OR MORE CHARACTERS
  _   ->UNDERSCORE -- REPRESENT SINGLE CHARACTER

  SYNTAX:
  =======

  LIKE 'PATTERN'

 EX:
 ===
  WRITE A QUERY TO DISPALY ALL ENAMES FROM EMP
  WHERE ENAME START WITH S.

 SOL:
 ====
  SELECT ENAME FROM EMP WHERE ENAME LIKE 'S%';

  ex:
  ===
  write a query to display all enames start with

  sol:
  =====

  select ename from emp where ename like 'A_L%';



 JOINS:
  ======
  Join are used to retrieve the records from multiple tables .

  join are used to create temporary a relation between the tables
  based on common column.

  if suppose we have n -tables ,then the atleast the possible join conditions are n-1.

  join are performed based on a common column datatype.


  There are two types of joins

 
  Equi-joins
 ----------
 inner join or simple join or equi join
  
 outer join--left [outer] join,right [outer] join,full[outer]join.
 self join 
  Non-Equi-joins
  cross join
 

 equi-joins:
 ============
 this joins performed based on equal operator (=).


 inner join:
 ============
 this join return or fetch all records based on condition matched.

 syntax:
 =======
 
 select * [specific columns] from table1 join table2
  on (table1.commoncolumname=table2.commoncolumnname).

 
  EX:
  ===

  write a inner join query to get empno,ename,sal,deptno from emp and
 deptno,dname from dept using alias name.

 sol:
 ====
 ANSI Syntax:
------------
  select e.deptno,e.empno,e.ename,e.sal,d.deptno,d.dname from 
  dept d join emp e  on (d.deptno=e.deptno);

  o/p:- 14 records using dept,emp table


 or

  select e.deptno,e.empno,e.ename,e.sal,d.deptno,d.dname from emp e,dept d where e.deptno=d.deptno;







 EX:2:
 =====

 write a inner or equijoin query to get empno,ename,sal from emp and
 deptno,dname from dept using alias name and display where deptno 20


 sol:
------
 select e.empno,e.ename,e.sal,d.deptno,d.dname from 
 dept d join emp e  on (d.deptno=e.deptno) where d.deptno=20

  or

 select e.empno,e.ename,e.sal,d.deptno,d.dname from emp e,dept d where e.deptno=d.deptno and d.deptno=20;

o/p= 5 records.






 OUTER JOIN:
 ===========

 LEFT OUTER JOIN:
 ================

 THIS JOINS RETRIVES OR FETCH ALL THE MATCHED RECORDS FROM BOTH TABLES
 AND NON-MATCHED  RECORDS FROM LEFT HAND SIDE TABLE IN JOIN.
 
 SYNTAX:
 ========

 SELECT * [SPECIFIC COLUMNS] FROM TABLE1 LEFT [OUTER] JOIN TABLE2
 ON (TABLE1.COMMNCOLUMNAME=TABLE2.COMMONCOLUMNNAME);

 NOTE:
 =====

 TABLE1 IS A LEFT TABLE.


 EX:
 ====
 WRITE A QUERY TO GET EMPNO,ENAME,SAL FROM EMP
 AND DEPTNO,DNAME FROM DEPT AND DISPLAY MATCHED REOCRDS FROM TWO TABLES
 AND NON MATCHED RECORDS FROM DEPT TABLE.

SOL:
===
	SELECT E.EMPNO,E.ENAME,E.SAL,D.DEPTNO,D.DNAME
	FROM DEPT D LEFT OUTER JOIN EMP E ON (D.DEPTNO=E.DEPTNO)
	

     O/P:- 14 MATCHED REOCRDS FROM DEPT,EMP TABLE  AND 2
          NON-MATCHED RECORD FROM DEPT TABLE.




 RIGHT OUTER JOIN:
 =================

 THIS JOIN RETRIVES OR FETCH ALL THE MATCHED RECORDS FROM BOTH THE
 TABLES AND NON- MATCHED RECORDS FROM RIGHT HAND SIDE TABLE IN JOIN.

 SYNTAX:
 ========

 SELECT * [SPECIFIC COLUMNS] FROM TABLE1 RIGHT [OUTER] JOIN TABLE2
 ON (TABLE1.COMMNCOLUMNAME=TABLE2.COMMONCOLUMNNAME);

 NOTE:
 =====

 TABLE2 IS RIGHT TABLE.

 EX:
===

 WRITE A QUERY TO DISPLLAY EMPNO,ENAME,SAL FROM EMP
 AND DEPTNO,DNAME FROM DEPT , display MATCHED RECORDS FROM
 BOTH THE TABLES AND NON MATCHED RECORDS FROM EMP TABLE 
 USING RIGHT OUTER JOIN.


SOL:
====
  SELECT E.empno,E.ENAME,E.SAL,D.DEPTNO,D.DNAME FROM
  DEPT D RIGHT OUTER JOIN EMP E ON (D.DEPTNO=E.DEPTNO);






 FULL OUTER JOIN:
 ================
 THIS JOIN RETRIVES OR FETCH ALL THE MATCHED AND NON-MATCHED
 RECORDS FROM THE BOTH THE TABLE.

SYNTAX:
========

SELECT * [SPECIFIC COLUMNS] FROM TABLE1 FULL [OUTER] JOIN TABLE2
ON (TABLE1.COMMNCOLUMNAME=TABLE2.COMMONCOLUMNNAME);

EX:
====

WRITE  A QUERY TO DISPLAY ALL THE RCORDS FROM BOTH TABLES
USING FULL OUTER JOIN.

EX:
====
 SELECT E.Empno,E.ENAME,E.SAL,D.DEPTNO,D.DNAME FROM
 DEPT D full OUTER JOIN EMP E ON (D.DEPTNO=E.DEPTNO);

  O/P:17 RECORDS.



OR
===
      SELECT E.EMPNO,E.ENAME,E.SAL,D.DEPTNO,D.DNAME
	FROM DEPT D ,EMP E WHERE D.DEPTNO=E.DEPTNO(+)        
        UNION 
        SELECT E.EMPNO,E.ENAME,E.SAL,D.DEPTNO,D.DNAME
	FROM DEPT D ,EMP E WHERE D.DEPTNO(+)=E.DEPTNO;


EX:
===

WRITE A EQUI JOIN QUERY TO GET DEPTNO,EMPNO,ENAME,SAL FROM EMP
DEPTNO,DNAME FROM DEPT
DEPTNO,HISAL FROM SALGRADE JOIN THREE TABLES.

SOL:
====

SELECT E.DEPTNO,E.ENAME,E.EMPNO,E.SAL,D.DEPTNO,D.DNAME,
S.DEPTNO,S.HISAL FROM 
DEPT D JOIN EMP E ON(D.DEPTNO=E.DEPTNO) JOIN SALGRADE S
ON (D.DEPTNO=S.DEPTNO);

O/P- 22 ROWS:


SELF JOIN:
==========
A SELF JOIN is  a join of a table itself.

note:
=====
 two table alias name we need to specify in from clause
 of same table.


 ex:
 ===

 write a self join query to display empolyee name along
 with his manager names using emp table.

 sol:
 ====
 select e.ename,m.ename as manager from emp e,emp m
 where e.mgr=m.empno;


 CROSS JOIN:
 ===========
 
 THIS PERFORMS CARTIESAN PRODUCT

 EX:
 ===

 WRITE A QUERY TO PERFORM CROSS JOIN USING DEPT,EMP

 DEPT--5
 EMP --15

 CROSS JOIN:- 5*15=75 RECORDS.

 SOL:
 ====
 SELECT E.EMPNO,E.ENAME,D.DEPTNO,D.DNAME FROM 
 DEPT D CROSS JOIN EMP E;

 or 
    
SELECT E.EMPNO,E.ENAME,D.DEPTNO,D.DNAME FROM
    DEPT D,EMP E;


 NATURAL JOIN:
 =============
 NATURAL JOIN IS SIMILAR TO INNER JOIN,
 BUT THE CONDITION IS PERFORMED IMPLICITY BASED ON COLUMN NAME.

 EX:
 ===   

 SELECT E.ENAME,D.DNAME FROM
 DEPT D NATURAL JOIN EMP E;

 NOTE:
 ===== 
 IN NATURAL JOIN THE COMMON COLUMN NAME BETWEEN  THE TWO TABLE
 MUST BE SAME. IF NOT IT WILL PERFORM CROSS JOIN

 NATURAL JOIN IS DEPENDENT ON COLUMN NAME .




NON-EQUI JOIN:
==============
=,!= OTHER THAN THIS OPERATORS(between,in,...)


SALGRADE Table
------------------
CREATE TABLE SALGRADE (GRADE int,LOSAL int,HISAL int); 

INSERT INTO SALGRADE VALUES (1,  700, 1200); 
INSERT INTO SALGRADE VALUES (2, 1201, 1400); 
INSERT INTO SALGRADE VALUES (3, 1401, 2000); 
INSERT INTO SALGRADE VALUES (4, 2001, 3000); 
INSERT INTO SALGRADE VALUES (5, 3001, 9999);


1)WRITE A NON-EQUI JOIN QUERY 
TO GET EMPNO,ENAME,SAL FROM EMP
GRADE FROM SAL GRADE
AND DISPLAY SALARIES BASED ON E.SAL COLUMN BETWEEN
THE RANGE OF LOSAL AND HISAL COLUMNS OF SALGRADE TABLE.

SOL:
=====

SELECT E.EMPNO,E.ENAME,E.SAL,S.GRADE
FROM EMP E,SALGRADE S WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL;



VIEWS:
======
A VIEW IS A LOGICAL REPRESENTATION OF DATA FROM ONE OR MORE THEN ONE TABLE.

A VIEW DOES NOT CONTAIN PHYSICAL STORAGE.

A VIEW IS VIRTUAL TABLE.

View does not contain any data.  

When we write select statement on view, we get the data from the table for the first time.

Advantages of MySQL Views
-------------------------
MySQL views bring the following advantages.

1) Simplify complex query
Views help simplify complex queries. If you have any frequently used complex query, you can create a view based on it so that you can reference the view by using a simple SELECT statement instead of typing the query all over again.

2) Make the business logic consistent
Suppose you have to repeatedly write the same formula in every query.  Or you have a query that has complex business logic. To make this logic consistent across queries, you can use a view to store the calculation and hide the complexity.

3) Add extra security layers

A table may expose a lot of data including sensitive data such as personal and banking information.

By using views and privileges, you can limit which data users can access by exposing only the necessary data to them.

For example, the table employees may contain SSN and address information, which should be accessible by the HR department only.

To expose general information such as first name, last name, and gender to the General Administration (GA) department, you can create a view based on these columns and grant the users of the GA department the view, not the entire table employees .


 TYPES OF VIEW:
 ==============

 1)SIMPLE VIEW
 2)COMPLEX VIEW


 SIMPLE VIEW:
 ============
 1) A VIEW IS CREATED BASED ON SINGLE TABLE.

 2)IN SIMPLE VIEW DOESNOT CONTAIN FUNCTIONS OR GROUP BY CLAUSES.

 3)WE CAN PERFORM DML OPERATION ON SIMPLE VIEW.


 SYNTAX:
 ========
 CREATE OR REPLACE VIEW  VIEWNAME  AS SELECT * [SPECIFIC COLUMNS]
                                   FROM TABLENAME;

 EX:
 ===
 CREATE A VIEW ON EMP TABLE IT CONTAINS THREE COLUMNS
 EMPNO,ENAME,SAL

SOL:
====
CREATE or replace  VIEW EMP_V1 AS SELECT EMPNO,ENAME,SAL FROM EMP;


TO DISPLAY THE VIEW OUT PUT:
=============================
SELECT * FROM VIEWNAME;

ex:
====
select * from emp_v1;


to drop a view:
===============
drop view viewname;



 COMPLEX VIEW:
 =============

 A VIEW IS CREATED BASED ON MORE THAN ONE TABLE(JOINS).

 A COMPLEX VIEW CAN CONTAIN FUNCTIONs OR GROUP BY CLAUSE.

 A DML OPERATION PERFROMED ON COMPLEX VIEW INDIRECTLY.

 SYNTAX:
  =======

 CREATE OR REPLACE VIEW VIEWNAME AS SELECT * FROM TWOTABLES;

 EX:
 ===
 CREATE COMPLEX VIEW TO STORE EQUI JOIN OUTPUT OF DEPT AND EMP TABLE.

 SOL:
 ====
 CREATE OR REPLACE VIEW EMP_DEPT_EQ AS
     SELECT E.EMPNO,E.ENAME,E.SAL,D.DEPTNO,D.DNAME FROM 
         DEPT D JOIN EMP E ON (D.DEPTNO=E.DEPTNO);





Read Only View:
===============
We can restrict DML operation views by creating read only view.
Ex:

Create or replace view v3 As select empno, ename, sal, deptno from emp with read only; 



With Check Option View::
====================
These views will allow DML operation only when where condition is satisfied. 

Ex:
Create view Test_V12
As select empno, ename, sal, deptno from emp Where deptno = 30 With check option;


ex:
insert into test_v12 values(7143,'RAJESH',5000,30) //valid
insert into test_v12 values(7323,'RAJESH',5000,10) //invalid




Different between simple and complex views?

Simple view						Complex view
1.Created by using only one table.	  1. Created by using multiple tables.
2.DML operations are allowed.		  2. DML operations are not allowed.
3.Should not be created using		  3. Can be created using arithmetic arithmetic operations or functions  operations                      or functions or or group by clauses.
group by clauses.



Exercises:
----------
salesman
---------
create below table.

 salesman_id |    name    |   city   | commission 
-------------+------------+----------+------------
        5001 | James Hoog | New York |       0.15
        5002 | Nail Knite | Paris    |       0.13  
        5005 | Pit Alex   | London   |       0.11
        5006 | Mc Lyon    | Paris    |       0.14
        5007 | Paul Adam  | Rome     |       0.13
        5003 | Lauson Hen | San Jose |       0.12


1. From the following table, create a view for those salespeople who belong to the city of New York. 
2. From the following table, create a view for all salespersons. Return salesperson ID, name, and city.  

3. From the following table, create a view to locate the salespeople in the city 'New York'.

4. From the following table, create a view to count the number of unique customers, compute the average and the total purchase amount of customer orders by each date.

sol:
----
create  or replace view v_2 as select ord_date,count(distinct(customer_id)) as uniqueCustomer,
avg(purch_amt) as avg,sum(purch_amt) as sum from orders group by ord_date ;
 
tables:
-------- 
Sample table: customer

 customer_id |   cust_name    |    city    | grade | salesman_id 
-------------+----------------+------------+-------+-------------
        3002 | Nick Rimando   | New York   |   100 |        5001
        3007 | Brad Davis     | New York   |   200 |        5001
        3005 | Graham Zusi    | California |   200 |        5002
        3008 | Julian Green   | London     |   300 |        5002
        3004 | Fabian Johnson | Paris      |   300 |        5006
        3009 | Geoff Cameron  | Berlin     |   100 |        5003
        3003 | Jozy Altidor   | Moscow     |   200 |        5007
        3001 | Brad Guzan     | London     |       |        5005


create table customer(customer_id int,cust_name varchar(20),city varchar(10),grade int,salesman_id int);

insert into customer values(3002,'Nick Rimando','New York',100,5001);
insert into customer values(3007,'Brad Davis','New York',200 ,5001);
insert into customer values (3005,'Graham Zusi','California',200,5002);
insert into customer values (3008,'Julian Green',' London',300,5002);
insert into customer values (3004,'Fabian Johnson','Paris',300,5006);
insert into customer values (3009,'Geoff Cameron','Berlin',100,5003);
insert into customer values (3003,'Jozy Altidor','Moscow',200,5007);
insert into customer values (3001,' Brad Guzan','London',null,5005);

orders:
---------

ord_no      purch_amt   ord_date    customer_id  salesman_id
----------  ----------  ----------  -----------  -----------
70001       150.5       2012-10-05  3005         5002
70009       270.65      2012-09-10  3001         5005
70002       65.26       2012-10-05  3002         5001
70004       110.5       2012-08-17  3009         5003
70007       948.5       2012-09-10  3005         5002
70005       2400.6      2012-07-27  3007         5001
70008       5760        2012-09-10  3002         5001

create table orders (ord_no int,purch_amt float,ord_date date,customer_id int,salesman_id int);

insert into orders values(70001,150.5,'2012-10-05',3005,5002);
insert into orders values(70009,270.65,'2012-09-10',3001,5005);
insert into orders values(70002,65.26,'2012-10-05',3002,5001);
insert into orders values(70004,110.5,'2012-08-17',3009,5003);
insert into orders values(70007,948.5,'2012-09-10',3005,5002);
insert into orders values(70005,2400.6,'2012-07-27',3007,5001);
insert into orders values(70008,5760,'2012-09-10',3002,5001);
















-- Creating a VIEW named 'totalforday'
CREATE VIEW totalforday

-- Selecting columns 'ord_date', count of distinct 'customer_id', average 'purch_amt', and total 'purch_amt' from the 'orders' table
-- Grouping the result by the 'ord_date' column
AS SELECT ord_date, COUNT(DISTINCT customer_id), AVG(purch_amt), SUM(purch_amt)
FROM orders
GROUP BY ord_date;



Subqueries:
----------
Subqueries () are used to get the result based on unknown values. 

They are different type.

1.Single Row subquery
2.Multiple Row subquery
3.Multiple column subquery
4.Co−related subquery
5.Scalar subquery
6.Inline view

*Single Row Subquery:
---------------------
When subquery returns one row (1 value). It is called Single RowSubquery.

Ex: write a query to display details are having salary > 'ALLENS' sal ?

Select * from emp where sal > (select sal from emp where ename = 'ALLEN'); 

Note:
-----
Subqueries are executed first and then parent query is executed by using the result of sub query.


Level Two query:
----------------
Select * from emp where job = (select job from emp where ename = 'ALLEN') AND job = (select job from emp where ename = 'BLAKE');


Level Three query(nested sub-query):
------------------------------------
Select * from emp where sal > (select sal from emp Where ename = (select ename from emp Where empno = 7499));


Note: 
-----
The above query is three level query. Sub query can be nested upto 32 levels.



**Multiple Row Subquery:
------------------------
When subquery returns multiple rows. It is called multiple row salary.

Note: we should use multiple row operators with multiple row subqueries. 

They are three multiple row operators.
1.IN
2.ANY
3.ALL


All:
----
Select * from emp Where sal > ALL(Select sal from emp Where deptno = 30);

Any:
-----
Select * from emp where sal > ANY(select sal from emp where deptno = 30); or condition

internally:
-----------
select * from emp where sal > ANY(1600,1250,1250,2850);


Select * from emp where sal < Any(select sal from emp where deptno = 30);


*IN: 
-----
Select * from emp where ename IN('ALLEN', 'KING','FORD');

or

Select * from emp where ename IN(select ename from emp where deptno = 30);

Select * from emp where sal IN(select sal from emp where deptno = 30);








*MULTIPLE COLUMN SUBQUERY:
--------------------------
When subquery return more then one column. It is called multiple column subquery. 
We should use in operator with multiple column subqueries.

Select * from emp where(job,sal) IN(select job, sal from emp where deptno = 30); 


Exercise:
---------
write a subquery to find second highest salary emp table.

sol:
----
select max(sal) from emp where sal < (select max(sal) from emp);







Co-RELATED SUBQUERY:
--------------------
When subquery is executed in relation to parent query, it is called co−related subquery.

*write a query to display all the rows who are having salary greater than AVG salary his department?

Ex:
----
Select * from emp e where sal > (select AVG(sal) from emp where deptno = e.deptno);

Execution:
----------
The above example is a co−related subquery.
In co−related subquery, parent query is executed first and then subquery is executed in relation to result of parent query(parenet table alias name).



SCALAR subquery: 
---------------
when we use subquery in the select clause. It is called as Scalar subquery.
Scalar subquery are also called sub select.

write a query to display following output?

Deptno	Dname	        Loc		sumsal
10	Accounting	New York	8750
20	Research	Dallas		10875
30	Sales	        Chicago		14400
40	Operations	Boston		−−−−−−


Ex:
----
Select deptno, dname, loc, (Select sum(sal) from emp where deptno = d.deptno) Sum_sal from dept d;



*INLINE VIEW:
-------------
When a subquery is used in from clause. It is called INLINE view.

Ex:
------
select dept.deptno, subquery1.total_amt from dept, ( select emp.deptno, Sum(emp.sal) total_amt
 from emp group by deptno) subquery1 WHERE subquery1.deptno = dept.deptno





Exercises On Subqueries:
-------------------------
1. Write a query to display the employee name and hiredate for all
employees in the same department as Blake. Exclude Blake.

2.Create a query to display the employee number and name for all employees who earn
more than the average salary. Sort the results in descending order of salary.

3.Write a query to display the employee number and name for all
employees who work in a department with any employee whose name
contains a T. 

4.Display the employee name, department number, and job title for all
employees whose department location is Dallas. 

5.Display the employee name and salary of all employees who report to King.




Exists:
------
In the previous section, we used IN to link the inner query and the outer query in a subquerystatement. 

IN is not the only way to do so -- one can use many operators such as >, <, or =.

EXISTS is a special operator that we will discuss in this section.

EXISTS simply tests whether the inner query returns any row. If it does, then the outer query proceeds. If not, the outer query does not execute, and the entire SQL statement returns nothing.

The syntax for EXISTS is: 

SELECT "column_name1"
FROM "table_name1"
WHERE EXISTS
( SELECT *
 FROM "table_name2"
 WHERE [Condition] )

Example:

SELECT ename, deptno FROM emp WHERE EXISTS 
(SELECT * FROM emp WHERE sal >3500 )







INDEXES:
========
Index is a database object ,index is a pointer which
locates the phsyical data of a table.

we can create index explicity on columns,
so that we can increase the performance of the sql statement query.


TYPES OF INDEXES:
======================================
1)SIMPLE INDEX
2)COMPLEX INDEX OR COMPOSITE INDEX


SIMPLE INDEX:
=============

SIMPLE INDEX IS A INDEX WHICH IS CREATED BASED ON SINGLE COLUMN.

SYNTAX:
=======

CREATE  INDEX INDEXNAME ON  TABLENAME(COLUMNANME)

EX:
===
Before Index created:
---------------------

SELECT * FROM  employees WHERE hire_date > '2000-01-01';

create  index:
--------------
CREATE INDEX i_hire_date ON employees(hire_date);


After Index created:
---------------------
SELECT * FROM  employees WHERE hire_date > '2000-01-01';
    

NOTE:
======
WE NEED TO CREATE INDEX ON COLUMNS,THAT COLUMNS
FREQUENTLY USED IN WHERE CLAUSE.

WHEN CREATE INDEX THE TABLE WILL BE SCANNED BASED ON INDEX
 RANGE SCAN.


COMPLEX or composite index:
---------------------------
A COMPLEX INDEX IS CREATED BASED ON MORE THAN ONE COLUMN.

SYNTAX:
========
CREATE INDEX INDEXNAME ON TABLENAME(COL1,COL2...,COL32);

Ex:
---
Before Index created:
---------------------
SELECT  * FROM employees WHERE first_name = 'Georgi'AND last_name = 'Facello';

create index:
-------------

CREATE INDEX i_composite ON employees(first_name, last_name);


after index created:
--------------------
SELECT  * FROM employees WHERE first_name = 'Georgi'AND last_name = 'Facello';


3)Unique index:
----------------
Syntax:
--------
create unique index indexname on tablename(columns);

it will create the indexes on columns as well as it will create the unique constraints on 
columns(duplicates not allowed).
ex:
---
create unique index infy_fn_ln_uq on info_1(first_name,last_name);

select * from info_1 where first_name='smith' and last_name='joe';

explain select * from info_1 where first_name='smith' and last_name='joe';

it will executes the select query based on index scan

try to insert duplicates in info_1 table.

insert into info_1 values(4,'smith','joe','sa',5000);
insert into info_1 values(4,'smith','joe','sa',5000);//duplicates entery not allowed



to list indexes on table from database
=======================================
show index from tablename from databasename;

Ex:
show index from emp from parul;


to drop index:
--------------
DROP INDEX index_name ON table_name

or

alter table tablename drop index indexname;









dense_rank():
--------------
This function assigns a rank to each row within a partition. 

The ranks are assigned in a consecutive manner, if there two values are equal then they will be assigned the same rank, and the next rank value will be one greater than the previous rank assigned.

DENSE_RANK() On Sal column:
---------------------------
SELECT empno, ename, sal, DENSE_RANK() OVER (ORDER BY sal) my_rank  FROM emp;

Based on each department you need assign DENSE rank using PARTITION BY:
----------------------------------------------------------------
SELECT empno, ename, sal,deptno ,
DENSE_RANK() OVER (PARTITION BY deptno ORDER BY sal) dens_rank  
FROM emp;

Rank:
-----
This function assigns a rank to each row within a partition that has gaps. 

In this case, ranks are assigned in a non-consecutive manner i.e if there two records have the same value then they will be assigned the same rank, and the next rank value will be the previous rank plus the number of duplicates.

Examples:
---------
SELECT empno, ename, sal, RANK() OVER (ORDER BY sal) my_rank  FROM emp;  

Based on each department you need assign rank using PARTITION BY:
----------------------------------------------------------------
SELECT empno, ename, sal, deptno,RANK() OVER (PARTITION BY deptno ORDER BY sal) my_rank  FROM emp;  




SET OPERATORS:
==============
UNION
UNIONALL

Rules for set operators:
=======================
1. Number of columns used in the query should match.
2. column data type should match for the queries in set operators.

UNION:
======
THIS OPERATEOR UNION RETRIVES THE OUTPUT OF TWO QUERIES 
AND IT REMOVES DUPLICATE RECORDS.

CREATE TABLE DEPT_U1 AS SELECT * FROM DEPT;
CREATE TABLE DEPT_U2 AS SELECT * FROM DEPT;

INSERT SOME RECORDS INTO ABOVE TWO TABLES.

EX:
====

SELECT * FROM DEPT_U1
UNION
SELECT * FROM DEPT_U2;

---IT WILL REMOVE DUPLICATES RECORDS.

UNION ALL:
==========

SELECT * FROM DEPT_U1
UNION ALL
SELECT * FROM DEPT_U2;

NOTE:
=====
IT WILL DISPLAY ALL THE DUPLICATE RECORDS FROM TWO TABLES


STRING FUNCTIONS:
==================
This functions are used to perform  manipulation
on character data.

1)upper -- upper('string')-it will convert the lowercase into uppercase

2)lower --lower('string') -it wil convert the given string into lowecase
 
3)initcap--initcap('string') -it will display the given string as first letter in capital--in not mysql

4)length --length('string')-it will retrun no of characters count.

5)lpad: 
========
this function is used to add the character at the end of left 

syntax:
=======
lpad('string',length,chars);

ex:
====
write a query to add some characters to a given string;

ex:
====
select  lpad('raju',11,'welcome') from  dual;

6)rpad
=======
select  rpad('raju',11,'welcome') from  dual;


7)ltrim
=========
This function will remove the character from left side of 
a given string

syntax:
========

ltrim(string,chars);

ex:
===

write a query to remove the characters from left side a given string

sol:
====
select ltrim('welcome','we') from dual;


8)rtrim
========
this function will remove the characters from right side of a
given string.

syntax:-- rtrim('string',chars)
ex:
===

select rtrim('welcome to raju','raju') from dual;


9)trim
--------

this will remove the characters from left and right side end of a
given.

syntax:
=======
trim(unused from 'string');

ex:
===
select trim( 'i' from 'indiani') from dual;

10)substr
---------
this function will display a part of  string
from a given strin.

syntax:
=======
substr('string',startposition,no of character);

ex:
---
select  substr('welcome',4,2) from dual;


11)replace
==========
this function used to replace the characters

syntax:
=======
replace('string','oldchars','newchars');

ex:
===
select replace('chaitanya','ta','ka') from dual;

1)write a query to display string in upper case  from dual;

ex:
====
select upper('welcome to training') from dual;

2)write a query to display given string in lowercase from dual;

ex:
===
selet lower('WELCOME TO training')  from dual;


EXERCISES:
===========

1) WRITE A QUERY TO DISPLAY ENAME COLUMN IN LOWER CASE FROM EMP;

3)WRITE A QUERY TO REPLACE ENAME=SCOTT   WITH TIGER  FROM EMP;

select replace(ename,'SCOTT','TIGER') from emp

4)WRITE A QUERY TO DISPLAY SUBSTR  OF ALL ENAME  FIRST THREE
   CHARACTES FROM EMP;

select substr(ename,1,3) from emp;

syntax:
=======
substr('string',startposition,no of character);








NUMBER FUNCTIONS:
=================

ABS -- IT WILL DISPLAY ABSLOUTE VALUE INTEGER.

SYNTAX:
=======
ABS(NUM)

EX:
===
SELECT ABS(5),ABS(-5),ABS(NULL) FROM DUAL;

OLP:--  5,5,

SQRT:
=====
IT WILL RETRUN SQRT ROOT VALUE OF A NUMBER.

SYNTAX:
========

SQRT(NUM);

EX:
===

SELECT SQRT(4),SQRT(9),SQRT(5),SQRT(NULL),SQRT(256) FROM DUAL;

OLP:-- 2,3,2.36,

MOD:
====
THIS FUNCTION RETRUN REMAINDER.

SYNTAX
======

MOD(VALUE,DIVISON);

EX:
===
SELECT MOD(4,2),MOD(5,2) FROM dual;

O/P:- 0,1


CEIL:
======
THIS FUNCTION ROUND THE VALUE TO HIGHEST POSSIBLE VALUE

SYNTAX:
========

CEIL(NUM);

EX:
===

SELECT CEIL(4.5),CEIL(5),CEIL(4.2) FROM DUAL;

OLP:- 5,5,5

FLOOR:
======
THIS FUNCTION ROUND THE VALUE TO Lowest POSSIBLE VALUE

SYNTAX:
-------
FLOOR(NUM);

EX:
===

SELECT FLOOR(4.5),FLOOR(4.2),FLOOR(4.7) FROM DUAL;

O/P:- 4,4,4,

pow()
round()
rand() -to generate the random numbers;



LOGINCAL OPERATORS:
===================

AND 
OR

IS NULL OPERATOR:
=================
THIS RETRUN THE VALUES BASED ON SEARCH OF NULL VALUES.




Normalization:
=============
Normalization is process of removing redundancy and improving accurency of the database. 
Normalization can be achieved by using normal forms.

*1st Normal form (1NF):
----------------------- 
A database is in 1NF if it satisfies following rules.

Rule1: Each cell should have one value.
Rule2: Table should have primary key.

2nd Second Normal form (2NF):
==========================
A database is in 2NF if it satisfies following rules.
Rule1: Database should be in 1NF.
Rule2: There should be no partial dependency.

Partial dependency:
==================
When a non−key attribute is dependent on part of a primary key. Then these exists partial dependency.

3rd Normal form (3NF): 
====================
A database is in 3NF if it satisfies the following rules. 
Rule1: Database should be in 2nd NF.
Rule2: These should be no transitive dependency.

Transitive dependency: 
=====================
When a non key attribute is dependent on another non key attribute then these Exists transitive dependency .


Exercise normalization
----------------------------
The following table is already in first normal form (1NF). There is only one entry per field. 

Please convert this table to the third normal form (3NF) using the techniques you learned in this Unit.

Check the other solutions and comment them, if necessary. 

A table with the students and their grades in different topics.

UnitID	StudentID	Date	TutorID	Topic	Room	Grade	Book		TutEmail
U1	St1		23.02.03	Tut1	GMT	629	4.7	Deumlich	tut1@fhbb.ch
U2	St1		18.11.02	Tut3	GIn	631	5.1	Zehnder		tut3@fhbb.ch
U1	St4		23.02.03	Tut1	GMT	629	4.3	Deumlich	tut1@fhbb.ch
U5	St2		05.05.03	Tut3	PhF	632	4.9	Dümmlers	tut3@fhbb.ch
U4	St2		04.07.03	Tut5	AVQ	621	5.0	SwissTopo	tut5@fhbb.ch

sol:
----

unitID   topic date room book tutorID

tutorid  tutemail

studentID  Grade unitId









Common Table Expression (CTE) in MySQL:
------------------------------------
A Common Table Expression (CTE) is a temporary named result set that is defined within the scope of a single SQL query. 

It allows you to write complex queries in a more readable and maintainable manner, by breaking them down into smaller, logical steps. 

CTEs can be used in MySQL with the "WITH" keyword, followed by the name of the CTE and the SELECT statement that defines it. Once a CTE is defined, it can be referenced multiple times within the same query.

One of the main benefits of using CTEs is that they allow you to create recursive queries, which are queries that reference themselves. 

This can be useful for tasks such as generating hierarchical data or finding the shortest path between nodes in a graph. 

CTEs can also be used to simplify the syntax of complex joins, to create derived tables that can be used within other queries, or to improve query performance by reducing the number of times that a subquery needs to be executed

MySQL CTE Syntax
------------------
The basic syntax for creating a Common Table Expression (CTE) in MySQL is as follows:

WITH cte_name AS (
    SELECT column1, column2, ...
    FROM table_name
    WHERE condition
)
SELECT *
FROM cte_name;




 Syntax:multiple CTEs within the same query, by separating each CTE definition with a comma. For example:

WITH cte1 AS (
    SELECT column1, column2, ...
    FROM table1
    WHERE condition1
),
cte2 AS (
    SELECT column3, column4, ...
    FROM table2
    WHERE condition2
)
SELECT *
FROM cte1
JOIN cte2 ON cte1.column1 = cte2.column3;

In this example, two CTEs are defined: "cte1" and "cte2". The CTEs are then referenced in the main query by joining them on a common column and selecting all columns from both CTEs.

MySQL CTE Examples
------------------
An example of how Common Table Expressions (CTEs) can be used in MySQL:

Suppose you have a sales table with columns "product_name", "sales_date", and "revenue". 

You want to calculate the total revenue for each product over the past 30 days, as well as the percentage change in revenue compared to the previous 30-day period. You can use a CTE to calculate these metrics:

The following commands can be used to create the table:

CREATE TABLE sales (
    product_name VARCHAR(50),
    sales_date DATE,
    revenue DECIMAL(10, 2));

The following commands can be used to insert data into the table:

INSERT INTO sales (product_name, sales_date, revenue) VALUES 
    ('Product A', '2023-03-01', 1000), 
    ('Product A', '2023-03-15', 1500), 
    ('Product A', '2023-03-30', 2000), 
    ('Product B', '2023-03-01', 800), 
    ('Product B', '2023-03-15', 1200), 
    ('Product B', '2023-03-30', 1600),
    ('Product C', '2023-03-01', 500),
    ('Product C', '2023-03-15', 750),
    ('Product C', '2023-03-30', 1000);

);

Query:
-------
WITH sales_last_30_days AS (
    SELECT product_name, SUM(revenue) AS total_revenue
    FROM sales
    WHERE sales_date BETWEEN '2023-03-10' AND '2023-04-09'
    GROUP BY product_name
),
sales_previous_30_days AS (
    SELECT product_name, SUM(revenue) AS total_revenue
    FROM sales
    WHERE sales_date BETWEEN '2023-02-08' AND '2023-03-09'
    GROUP BY product_name
)
SELECT
    s.product_name,
    s.total_revenue,
    (s.total_revenue - p.total_revenue) / p.total_revenue * 100 AS revenue_change
FROM sales_last_30_days s
JOIN sales_previous_30_days p ON s.product_name = p.product_name;


Explanation:
------------
This CTE first calculates the total revenue for each product over the past 30 days and stores the result in a CTE called "sales_last_30_days". 

It then calculates the total revenue for each product over the previous 30-day period and stores the result in a CTE called "sales_previous_30_days". 

The main query joins these two CTEs on the "product_name" column and calculates the percentage change in revenue.

More Advanced MySQL CTE Example
-----------------------------
An example of more advanced Common Table Expressions (Recursive CTEs) in MySQL:

Suppose you have a database with a table called "sales" that contains sales data for a company. The "sales" table has columns for "order_date", "product", "quantity", and "revenue".

You want to create a report that shows the total revenue generated by each product, broken down by month. However, you also want to include a column that shows the percentage of total revenue generated by each product, based on the revenue generated by all products.

The following commands can be used to create the table:

CREATE TABLE sales (
  order_date DATE,
  product VARCHAR(50),
  quantity INT,
  revenue DECIMAL(10,2)
);


INSERT INTO sales (order_date, product, quantity, revenue) VALUES 
('2023-01-01', 'Product A', 10, 1000.00),
('2023-01-15', 'Product B', 5, 500.00),
('2023-02-01', 'Product A', 8, 800.00),
('2023-02-15', 'Product C', 3, 300.00),
('2023-03-01', 'Product A', 12, 1200.00),
('2023-03-15', 'Product B', 7, 700.00);


Query:
------
WITH monthly_sales AS (
  SELECT
    DATE_FORMAT(order_date, '%Y-%m') AS month,
    product,
    SUM(revenue) AS revenue
  FROM
    sales
  GROUP BY
    month,
    product
),
total_sales AS (
  SELECT
    month,
    SUM(revenue) AS total_revenue
  FROM
    monthly_sales
  GROUP BY
    month
)
SELECT
  monthly_sales.month,
  monthly_sales.product,
  monthly_sales.revenue,
  (monthly_sales.revenue / total_sales.total_revenue)*100 AS percentage
FROM
  monthly_sales
  JOIN total_sales ON monthly_sales.month = total_sales.month
ORDER BY
  monthly_sales.month,
  percentage DESC;


Benefits of Using CTE
-------------------
Here are some of the benefits of using Common Table Expressions (CTEs) in MySQL:

Simplify complex queries:
-----------------------
CTEs can be used to break down complex queries into smaller, more manageable parts. By defining CTEs, you can avoid writing complex subqueries multiple times, which can make your code easier to read and understand.

Improve query performance:
-------------------------
CTEs can help improve query performance by reducing the number of database scans required to execute a query. By defining a CTE, you can create a temporary table that can be used to store intermediate results, which can reduce the number of scans required to retrieve data.

Reuse code:
----------
CTEs can be used to create modular SQL code that can be reused across multiple queries. By defining a CTE at the beginning of a query, you can create a self-contained module that can be used in other queries, making your code more flexible and adaptable.

Traverse hierarchical data:
-------------------------
CTEs can be used to traverse hierarchical data structures, such as organizational charts or product categories. By defining a recursive CTE, you can traverse the hierarchy and perform complex calculations on the data.

Simplify debugging:
------------------
CTEs can help simplify debugging by breaking a complex query into smaller parts. By defining CTEs, you can analyze each part of the query individually, making it easier to identify and fix errors.

Improve code readability:
------------------------
CTEs can improve the readability of your SQL code by providing a clear and concise way to define temporary named result sets. By using descriptive names for your CTEs, you can make your code easier to read and understand.

